import re
from pathlib import Path

from pyscaffold import cli

from pyscaffoldext.clickstart.extension import Clickstart

EXT_FLAGS = [Clickstart().flag]

# If you need to check logs with caplog, have a look on
# pyscaffoldext-custom-extension's tests/conftest.py file and the
# `isolated_logger` fixture.


def test_add_custom_extension(tmpfolder):
    args = ["my_project", "--no-config", "--venv", "-p", "my_package", *EXT_FLAGS]
    # --no-config: avoid extra config from dev's machine interference
    cli.main(args)
    assert Path("my_project/src/my_package/__init__.py").exists()


# def test_add_custom_extension_and_pretend(tmpfolder):
#     args = ["my_project", "--no-config", "--pretend", "-p", "my_package", *EXT_FLAGS]
#     # --no-config: avoid extra config from dev's machine interference
#     cli.main(args)
#
#     assert not Path("my_project").exists()


# def test_add_custom_extension_with_namespace(tmpfolder):
#     args = [
#         "my_project",
#         "--no-config",  # avoid extra config from dev's machine interference
#         "--package",
#         "my_package",
#         "--namespace",
#         "my.ns",
#         *EXT_FLAGS,
#     ]
#     cli.main(args)
#
#     assert Path("my_project/src/my/ns/my_package/__init__.py").exists()


# To use marks make sure to uncomment them in setup.cfg
# @pytest.mark.slow
# def test_generated_extension(tmpfolder):
#     args = [
#         "my_project",
#         "--no-config",  # avoid extra config from dev's machine interference
#         "--venv",  # generate a venv so we can install the resulting project
#         "--pre-commit",  # ensure generated files respect repository conventions
#         "--namespace",  # it is very easy to forget users might want to use namespaces
#         "my.ns",  # ... so we automatically test the worst case scenario
#         *EXT_FLAGS,
#     ]
#     cli.main(args)
#
#     with chdir("my_project"):
#         # Testing a project generated by the custom extension
#         run_common_tasks()


def test_makefile_shell_escaping(tmpfolder):
    """Test that generated Makefile has correct shell variable escaping.

    Validates fixes for:
    - Bug 1: Version parsing should use sed/cut (not shell parameter expansion)
    - Bug 2: Release targets should escape shell vars with $$ for Make
    """
    args = ["my_project", "--no-config", "--venv", "-p", "my_package", *EXT_FLAGS]
    cli.main(args)

    makefile_path = Path("my_project/Makefile")
    assert makefile_path.exists(), "Makefile should be generated"

    makefile_content = makefile_path.read_text()

    # Bug 1: Version parsing should use sed/cut approach (not shell parameter expansion)
    # The old buggy approach used: $(shell sh -lc 't="$(LAST_TAG)"; t="${t#v}"; ...')
    # which fails because Make interprets ${...} as variable expansion
    assert "sed 's/^v//'" in makefile_content, (
        "MAJOR/MINOR/PATCH should use sed for version parsing"
    )
    assert "cut -d. -f1" in makefile_content, "MAJOR should use cut -d. -f1"
    assert "cut -d. -f2" in makefile_content, "MINOR should use cut -d. -f2"
    assert "cut -d. -f3" in makefile_content, "PATCH should use cut -d. -f3"

    # Bug 2: Release targets must escape shell variables with $$ for Make
    # In Make recipes, $VAR is interpreted by Make; $$VAR passes $ to shell

    # Check that release-patch uses correct escaping
    release_patch_match = re.search(
        r"release-patch:.*?(?=\n\n|\nrelease-minor:|\Z)",
        makefile_content,
        re.DOTALL,
    )
    assert release_patch_match, "release-patch target should exist"
    release_patch = release_patch_match.group(0)

    # Shell variables must be escaped as $$VAR
    assert "$$NEW" in release_patch, "Shell variable NEW must be escaped as $$NEW"
    assert "$$TMP" in release_patch, "Shell variable TMP must be escaped as $$TMP"
    assert "$$(mktemp" in release_patch, "mktemp command must be escaped as $$(mktemp"
    assert "$$(($(PATCH)" in release_patch, (
        "Shell arithmetic must be escaped as $$(( with Make var $(PATCH)"
    )

    # Check release-minor similarly
    release_minor_match = re.search(
        r"release-minor:.*?(?=\n\n|\nrelease-major:|\Z)",
        makefile_content,
        re.DOTALL,
    )
    assert release_minor_match, "release-minor target should exist"
    release_minor = release_minor_match.group(0)
    assert "$$(($(MINOR)" in release_minor, (
        "release-minor should have correctly escaped shell arithmetic"
    )

    # Check release-major similarly
    release_major_match = re.search(
        r"release-major:.*?(?=\n\n|\nrelease:|\Z)",
        makefile_content,
        re.DOTALL,
    )
    assert release_major_match, "release-major target should exist"
    release_major = release_major_match.group(0)
    assert "$$(($(MAJOR)" in release_major, (
        "release-major should have correctly escaped shell arithmetic"
    )
