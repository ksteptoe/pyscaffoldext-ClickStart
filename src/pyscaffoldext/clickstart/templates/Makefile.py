# --- Makefile (generated by PyScaffold-Clickstart) ----------------------------
# This Makefile provides:
#  - Auto-versioned build & release helpers (setuptools-scm)
#  - Linting/formatting with Ruff & pre-commit
#  - Incremental, cached pytest pipelines (unit/cli/e2e)
#  - Git tag-based release versioning
#
# Generated project: {{ project_name }}
# Package import name: {{ package_name }}
# -----------------------------------------------------------------------------#

.SILENT:
.ONESHELL:
SHELL := $(shell which bash)
.SHELLFLAGS := -eu -o pipefail -c

# Pick a Python: use 'python' if present, else Windows launcher 'py -3'
PYTHON := $(shell command -v python >/dev/null 2>&1 && echo python || echo py -3)

# What counts as "code/config" for triggering re-runs
CODE_DIRS   := src/{{ package_name }}
CONF_FILES  := pyproject.toml {{ package_name }}_config.yml
CONFIG_DIRS :=

# Optional env toggle to bypass the stamp cache:
#   make test NO_CACHE=1
NO_CACHE ?= 0

# Pytest flags
PYTEST        := $(PYTHON) -m pytest
PYTEST_Q      := -q
PYTEST_WARN   := --disable-warnings
PYTEST_COV    := --cov={{ package_name }} --cov-report=xml --cov-fail-under=30
PYTEST_XDIST  ?= -n auto
PYTEST_TIMEOUT ?= --timeout=60

# -----------------------------------------------------------------------------#
# Default test paths (no legacy integration/process/run)
UNIT_DIR      := tests/unit
CLI_SMOKE_DIR := tests/cli/smoke
CLI_DIR       := tests/cli
E2E_DIR       := tests/e2e

# Allowed release branch (override: make TARGET_BRANCH=trunk)
TARGET_BRANCH ?= main
TARGET_BRANCH := $(strip $(TARGET_BRANCH))

.PHONY: help which-python version \
        fetch-tags check-clean ensure-branch ensure-new-tag \
        release-show release-dryrun release release-patch release-minor release-major release-notes \
        build upload push-all retag clean \
        lint format precommit ruff ruff-fix \
        test test-fast test-smoke test-cli test-e2e test-all \
        clean-tests clean-unit clean-cli-smoke clean-cli clean-e2e run-cli

# Help ------------------------------------------------------------------------
help:
        @echo "Usage:"
        @echo "  make which-python        # show Python path/version used by Makefile"
        @echo "  make version             # print setuptools_scm version (if available)"
        @echo ""
        @echo "Release:"
        @echo "  make release-show        # show setuptools_scm ver + last semver tag"
        @echo "  make release-dryrun      # compute next patch/minor/major (no tagging)"
        @echo "  make release-patch       # tag vX.Y.(Z+1) and push"
        @echo "  make release-minor       # tag vX.(Y+1).0 and push"
        @echo "  make release-major       # tag v(X+1).0.0 and push"
        @echo "  make release-notes       # git log since last tag"
        @echo "  make retag VERSION=X.Y.Z # move tag vX.Y.Z to HEAD (force)"
        @echo ""
        @echo "Build & publish:"
        @echo "  make build               # build wheel + sdist (dist/*)"
        @echo "  make upload              # twine check + upload dist/*"
        @echo "  make push-all            # push current branch + all tags"
        @echo ""
        @echo "Lint/format:"
        @echo "  make lint                # ruff check + ruff format --check"
        @echo "  make format              # ruff check --fix + ruff format"
        @echo "  make precommit           # run pre-commit hooks (fallback: format)"
        @echo ""
        @echo "Tests (incremental, cached with .stamps/):"
        @echo "  make test                # unit only (fast lane, default)"
        @echo "  make test-smoke          # tests/cli/smoke (tiny CLI sanity)"
        @echo "  make test-cli            # full CLI suite"
        @echo "  make test-e2e            # end-to-end tests"
        @echo "  make test-all            # unit + cli + e2e"
        @echo ""
        @echo "Clean:"
        @echo "  make clean               # build artifacts, caches"
        @echo "  make clean-tests         # remove all test stamps/sigs"
        @echo ""
        @echo "CLI convenience:"
        @echo "  make run-cli ROOT=.      # run '{{ package_name }}' CLI against ROOT"

which-python:
        @echo "Using PYTHON=$(PYTHON)"
        @$(PYTHON) -c "import sys,platform; print(sys.executable); print(platform.python_version())"

version:
        @$(PYTHON) -m setuptools_scm || true

# -----------------------------------------------------------------------------#
# Release helpers (setuptools-scm + Git tags)

TAG ?=

fetch-tags:
        @git fetch --tags --force --prune 2>/dev/null || true

LAST_TAG := $(shell git describe --tags --abbrev=0 --match "v[0-9]*.[0-9]*.[0-9]*" 2>/dev/null || echo v0.0.0)
MAJOR    := $(shell echo "$(LAST_TAG)" | sed -E 's/^v([0-9]+)\..*/\1/')
MINOR    := $(shell echo "$(LAST_TAG)" | sed -E 's/^v[0-9]+\.([0-9]+)\..*/\1/')
PATCH    := $(shell echo "$(LAST_TAG)" | sed -E 's/^v[0-9]+\.[0-9]+\.([0-9]+)/\1/')

check-clean:
        @if ! git diff --quiet || ! git diff --cached --quiet; then \
          echo "Working tree is dirty. Commit or stash first."; exit 1; \
        fi

ensure-branch:
        @cur="$$(git rev-parse --abbrev-ref HEAD)"; \
        if [ "$$cur" != "$(TARGET_BRANCH)" ]; then \
          echo "Refusing: on '$$cur' not '$(TARGET_BRANCH)'"; exit 1; \
        fi

ensure-new-tag:
        @if git rev-parse -q --verify "refs/tags/$(NEW)" >/dev/null; then \
          echo "Tag $(NEW) already exists. Aborting."; exit 1; \
        fi

release-show: fetch-tags
        @echo "python exe:"; $(PYTHON) -c "import sys; print(sys.executable)"
        @echo "setuptools_scm version:"; $(PYTHON) -m setuptools_scm || echo "(unavailable)"
        @echo "installed dist version:"; $(PYTHON) -c "import importlib.metadata as m; print(m.version('{{ package_name }}'))" || echo "(package not installed)"
        @echo "Last Git tag: $(LAST_TAG)"

release-dryrun: fetch-tags
        @echo "Last tag: $(LAST_TAG)"
        @echo "Patch -> v$(MAJOR).$(MINOR).$$(( $(PATCH) + 1 ))"
        @echo "Minor -> v$(MAJOR).$$(( $(MINOR) + 1 )).0"
        @echo "Major -> v$$(( $(MAJOR) + 1 )).0.0"
        @echo "setuptools_scm says:"; $(PYTHON) -m setuptools_scm || true

release: fetch-tags check-clean ensure-branch
        @if [ -z "$(TAG)" ]; then echo "Usage: make release TAG=X.Y.Z"; exit 1; fi
        NEW=v$(TAG); \
        $(MAKE) ensure-new-tag NEW=$$NEW; \
        echo "Tagging $$NEW"; git tag -a "$$NEW" -m "release: $$NEW"; git push origin "$$NEW"

release-patch: fetch-tags check-clean ensure-branch
        NEW=v$(MAJOR).$(MINOR).$$(( $(PATCH) + 1 ))
        $(MAKE) ensure-new-tag NEW=$$NEW
        echo "Tagging $$NEW"; git tag -a "$$NEW" -m "release: $$NEW"; git push origin "$$NEW"

release-minor: fetch-tags check-clean ensure-branch
        NEW=v$(MAJOR).$$(( $(MINOR) + 1 )).0
        $(MAKE) ensure-new-tag NEW=$$NEW
        echo "Tagging $$NEW"; git tag -a "$$NEW" -m "release: $$NEW"; git push origin "$$NEW"

release-major: fetch-tags check-clean ensure-branch
        NEW=v$$(( $(MAJOR) + 1 )).0.0
        $(MAKE) ensure-new-tag NEW=$$NEW
        echo "Tagging $$NEW"; git tag -a "$$NEW" -m "release: $$NEW"; git push origin "$$NEW"

release-notes: fetch-tags
        @git log --pretty=format:'* %h %s' $(LAST_TAG)..HEAD

# ------------------- Build & upload ------------------------------------------
build:
        $(PYTHON) -m pip install -U build
        $(PYTHON) -m build

upload: build
        $(PYTHON) -m pip install -U twine
        twine check dist/*
        twine upload dist/*

push-all:
        git push origin $(TARGET_BRANCH)
        git push --tags

retag:
        @if [ -z "$(VERSION)" ]; then echo "Usage: make retag VERSION=1.2.3"; exit 1; fi
        git tag -f "v$(VERSION)"
        git push -f origin "v$(VERSION)"

clean:
        rm -rf build dist .eggs *.egg-info .coverage htmlcov .pytest_cache
        find . -type d -name "__pycache__" -prune -exec rm -rf {} +
        rm -rf .stamps

# -----------------------------------------------------------------------------#
# Lint/format
lint:
        ruff check .
        ruff format --check .

format:
        ruff check --fix .
        ruff format .

precommit:
        @if command -v pre-commit >/dev/null 2>&1; then \
          echo "Running pre-commit hooks..."; \
          pre-commit run -a; \
        else \
          echo "pre-commit not installed, running fallback lint/format..."; \
          $(MAKE) format; \
        fi

# -----------------------------------------------------------------------------#
# Incremental test pipeline (stamps v2 â€” unit/cli/e2e)

STAMPS_DIR := .stamps

UNIT_STAMP      := $(STAMPS_DIR)/unit.ok
CLI_SMOKE_STAMP := $(STAMPS_DIR)/cli_smoke.ok
CLI_STAMP       := $(STAMPS_DIR)/cli.ok
E2E_STAMP       := $(STAMPS_DIR)/e2e.ok

UNIT_SIG      := $(STAMPS_DIR)/unit.sig
CLI_SMOKE_SIG := $(STAMPS_DIR)/cli_smoke.sig
CLI_SIG       := $(STAMPS_DIR)/cli.sig
E2E_SIG       := $(STAMPS_DIR)/e2e.sig

.PHONY: FORCE
FORCE:

$(STAMPS_DIR):
        mkdir -p $@

define compute_dir_sig
{ [ -d "$(1)" ] && find $(1) -type f -not -path "*/__pycache__/*" -print0 || true; } \
| LC_ALL=C sort -z | xargs -0r sha1sum | sha1sum | awk '{print $$1}'
endef

define compute_dirs_sig
{ for d in $(1); do [ -d "$$d" ] && find "$$d" -type f -not -path "*/__pycache__/*" -print0; done; } \
| LC_ALL=C sort -z | xargs -0r sha1sum | sha1sum | awk '{print $$1}'
endef

define compute_files_sig
{ for f in $(1); do [ -f "$$f" ] && sha1sum "$$f"; done; } | sha1sum | awk '{print $$1}'
endef

# 0) UNIT ---------------------------------------------------------------------
$(UNIT_STAMP): FORCE | $(STAMPS_DIR)
        @tests_sig=$$( $(call compute_dir_sig,$(UNIT_DIR)) ); \
        code_sig=$$( $(call compute_dirs_sig,$(CODE_DIRS) $(CONFIG_DIRS)) ); \
        conf_sig=$$( $(call compute_files_sig,$(CONF_FILES)) ); \
        new_sig=$$( printf "%s\n%s\n%s\n" "$$tests_sig" "$$code_sig" "$$conf_sig" | sha1sum | awk '{print $$1}' ); \
        old_sig=$$(cat $(UNIT_SIG) 2>/dev/null || echo -n); \
        if [ "$(NO_CACHE)" = "1" ] || [ "$$new_sig" != "$$old_sig" ] || [ ! -f $@ ]; then \
          echo "=== Running UNIT tests ==="; \
          $(PYTEST) $(PYTEST_Q) $(UNIT_DIR) -m "not slow" $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) $(PYTEST_COV) || \
          $(PYTEST) $(PYTEST_Q) $(UNIT_DIR) -m "not slow" $(PYTEST_WARN) $(PYTEST_COV); \
          echo "$$new_sig" > $(UNIT_SIG); \
          touch $@; \
        else echo "UNIT unchanged; skipping"; fi

# 1) CLI SMOKE ---------------------------------------------------------------
$(CLI_SMOKE_STAMP): FORCE $(UNIT_STAMP) | $(STAMPS_DIR)
        @tests_sig=$$( $(call compute_dir_sig,$(CLI_SMOKE_DIR)) ); \
        code_sig=$$( $(call compute_dirs_sig,$(CODE_DIRS) $(CONFIG_DIRS)) ); \
        conf_sig=$$( $(call compute_files_sig,$(CONF_FILES)) ); \
        up_sig=$$(cat $(UNIT_SIG) 2>/dev/null || echo -n); \
        new_sig=$$( printf "%s\n%s\n%s\n%s\n" "$$tests_sig" "$$code_sig" "$$conf_sig" "$$up_sig" | sha1sum | awk '{print $$1}' ); \
        old_sig=$$(cat $(CLI_SMOKE_SIG) 2>/dev/null || echo -n); \
        if [ "$(NO_CACHE)" = "1" ] || [ "$$new_sig" != "$$old_sig" ] || [ ! -f $@ ]; then \
          echo "=== Running CLI SMOKE tests ==="; \
          $(PYTEST) $(PYTEST_Q) $(CLI_SMOKE_DIR) $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) || \
          $(PYTEST) $(PYTEST_Q) $(CLI_SMOKE_DIR) $(PYTEST_WARN); \
          echo "$$new_sig" > $(CLI_SMOKE_SIG); \
          touch $@; \
        else echo "CLI SMOKE unchanged; skipping"; fi

# 2) CLI (full) ---------------------------------------------------------------
$(CLI_STAMP): FORCE $(UNIT_STAMP) | $(STAMPS_DIR)
        @tests_sig=$$( $(call compute_dir_sig,$(CLI_DIR)) ); \
        code_sig=$$( $(call compute_dirs_sig,$(CODE_DIRS) $(CONFIG_DIRS)) ); \
        conf_sig=$$( $(call compute_files_sig,$(CONF_FILES)) ); \
        up_sig=$$(cat $(UNIT_SIG) 2>/dev/null || echo -n); \
        new_sig=$$( printf "%s\n%s\n%s\n%s\n" "$$tests_sig" "$$code_sig" "$$conf_sig" "$$up_sig" | sha1sum | awk '{print $$1}' ); \
        old_sig=$$(cat $(CLI_SIG) 2>/dev/null || echo -n); \
        if [ "$(NO_CACHE)" = "1" ] || [ "$$new_sig" != "$$old_sig" ] || [ ! -f $@ ]; then \
          echo "=== Running CLI tests ==="; \
          $(PYTEST) $(PYTEST_Q) $(CLI_DIR) $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) || \
          $(PYTEST) $(PYTEST_Q) $(CLI_DIR) $(PYTEST_WARN); \
          echo "$$new_sig" > $(CLI_SIG); \
          touch $@; \
        else echo "CLI unchanged; skipping"; fi

# 3) E2E ----------------------------------------------------------------------
$(E2E_STAMP): FORCE $(CLI_STAMP) | $(STAMPS_DIR)
        @tests_sig=$$( $(call compute_dir_sig,$(E2E_DIR)) ); \
        code_sig=$$( $(call compute_dirs_sig,$(CODE_DIRS) $(CONFIG_DIRS)) ); \
        conf_sig=$$( $(call compute_files_sig,$(CONF_FILES)) ); \
        up_sig=$$(cat $(CLI_SIG) 2>/dev/null || echo -n); \
        new_sig=$$( printf "%s\n%s\n%s\n%s\n" "$$tests_sig" "$$code_sig" "$$conf_sig" "$$up_sig" | sha1sum | awk '{print $$1}' ); \
        old_sig=$$(cat $(E2E_SIG) 2>/dev/null || echo -n); \
        if [ "$(NO_CACHE)" = "1" ] || [ "$$new_sig" != "$$old_sig" ] || [ ! -f "$(E2E_STAMP)" ]; then \
          echo "=== Running E2E tests ==="; \
          $(PYTEST) -o addopts='' $(PYTEST_Q) $(E2E_DIR) -m "e2e" $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) $(PYTEST_COV); \
          status=$$?; \
          if [ $$status -eq 5 ]; then \
            echo "No E2E tests selected; skipping"; true; \
          else exit $$status; fi; \
          echo "$$new_sig" > $(E2E_SIG); \
          touch $(E2E_STAMP); \
        else echo "E2E unchanged; skipping"; fi

# Convenience targets ----------------------------------------------------------
test: $(UNIT_STAMP)
        @echo "OK unit up-to-date ($(UNIT_STAMP))"

test-fast: $(UNIT_STAMP)
        @echo "OK unit up-to-date ($(UNIT_STAMP))"

test-smoke: $(CLI_SMOKE_STAMP)
        @echo "OK cli smoke up-to-date ($(CLI_SMOKE_STAMP))"

test-cli: $(CLI_STAMP)
        @echo "OK cli up-to-date ($(CLI_STAMP))"

test-e2e: $(E2E_STAMP)
        @echo "OK e2e up-to-date ($(E2E_STAMP))"

test-all: $(UNIT_STAMP) $(CLI_SMOKE_STAMP) $(CLI_STAMP) $(E2E_STAMP)
        @echo "All lanes up-to-date ($(STAMPS_DIR))"

clean-tests:
        rm -rf $(STAMPS_DIR)

clean-unit:
        rm -f $(UNIT_SIG) $(UNIT_STAMP)

clean-cli-smoke:
        rm -f $(CLI_SMOKE_SIG) $(CLI_SMOKE_STAMP)

clean-cli:
        rm -f $(CLI_SIG) $(CLI_STAMP)

clean-e2e:
        rm -f $(E2E_SIG) $(E2E_STAMP)

# -----------------------------------------------------------------------------#
# CLI convenience
ROOT ?= .
CLI_ARGS ?=
run-cli:
        {{ package_name }} $(ROOT) $(CLI_ARGS)
