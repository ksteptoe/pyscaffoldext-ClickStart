"""PyScaffold extension for generating Click-based CLI projects.

This module provides the ClickStart extension for PyScaffold, which generates
a modern, production-ready Python CLI project structure with:

- Click-based command-line interface
- Modern pyproject.toml-only configuration (no setup.py/setup.cfg)
- Ruff for linting and formatting
- pytest with unit/integration test separation
- Sphinx documentation with MyST-Parser for Markdown
- Makefile for common development tasks
- Pre-commit hooks configured

Example usage::

    putup --clickstart my_project
    cd my_project
    make bootstrap
    make test

The extension registers several actions that modify the PyScaffold structure:

1. ``add_files`` - Adds CLI, API, and test files
2. ``add_clickstart_templates`` - Adds Makefile, pyproject.toml, pre-commit config
3. ``add_markdown_docs`` - Replaces RST docs with Markdown equivalents
4. ``reject_file`` - Removes unwanted default files (skeleton.py, setup.py, etc.)
"""

from __future__ import annotations

from functools import reduce
from importlib.metadata import packages_distributions
from importlib.metadata import version as dist_version
from pathlib import Path
from typing import List

from pyscaffold.actions import Action, ActionParams, ScaffoldOpts, Structure
from pyscaffold.extensions import Extension
from pyscaffold.operations import no_overwrite
from pyscaffold.structure import (
    Leaf,
    ResolvedLeaf,
    merge,
    reify_content,
    reject,
    resolve_leaf,
)
from pyscaffold.templates import get_template
from pyscaffold.update import ConfigUpdater

from . import templates as my_templates

NO_OVERWRITE = no_overwrite()

# For backward compatibility only â€” safe to remove once setup.cfg is deprecated
REQUIREMENT_DEPENDENCIES = (
    "click>=8.1",
    "pytest>=8",
    "pytest-cov>=5",
)


def _substitute_brace_vars(text: str, opts: ScaffoldOpts) -> str:
    """Substitute brace-style template variables with project values.

    Replaces placeholders like ``{{ project_name }}`` and ``{{ package_name }}``
    with actual values from the scaffold options. Supports multiple placeholder
    formats for flexibility.

    Args:
        text: Template text containing placeholders to substitute.
        opts: PyScaffold options dictionary containing project/package names.
            Expected keys: 'project', 'package' (or fallbacks 'project_name',
            'package_name', 'name').

    Returns:
        Text with all placeholders replaced by actual values.

    Supported placeholders:
        - ``{{ project_name }}``, ``{{project_name}}``
        - ``{{ ProjectName }}``, ``{{ProjectName}}``
        - ``{{ package_name }}``, ``{{package_name}}``
        - ``{{ PackageName }}``, ``{{PackageName}}``
        - ``{{package}}``

    Example:
        >>> opts = {'project': 'my-app', 'package': 'my_app'}
        >>> _substitute_brace_vars('Hello {{ project_name }}', opts)
        'Hello my-app'
    """
    project = opts.get("project") or opts.get("project_name") or opts.get("name") or "project"
    package = opts.get("package") or opts.get("package_name") or project.replace("-", "_")
    return (
        text.replace("{{ project_name }}", project)
        .replace("{{project_name}}", project)
        .replace("{{ ProjectName }}", project)
        .replace("{{ProjectName}}", project)
        .replace("{{ package_name }}", package)
        .replace("{{package_name}}", package)
        .replace("{{ PackageName }}", package)
        .replace("{{PackageName}}", package)
        .replace("{{package}}", package)
    )


def modify_gitignore(definition: Leaf, opts: ScaffoldOpts) -> ResolvedLeaf:
    """Modify .gitignore to include setuptools_scm generated version file.

    Ensures the auto-generated ``src/<package>/_version.py`` file is ignored
    by git, as it's regenerated on each build by setuptools_scm.

    Args:
        definition: Existing .gitignore content as a Leaf tuple (content, operation).
        opts: PyScaffold options containing project and package names.

    Returns:
        ResolvedLeaf tuple with modified content and preserved operation.

    Note:
        This function is idempotent - if the version file line already exists,
        it won't be added again.
    """
    contents, original_op = resolve_leaf(definition)
    txt = reify_content(contents, opts) if contents is not None else ""

    project = opts.get("project") or "project"
    package = opts.get("package") or project.replace("-", "_")
    line = f"src/{package}/_version.py"

    if line not in txt.splitlines():
        if txt and not txt.endswith("\n"):
            txt += "\n"
        txt += "# Generated by setuptools_scm\n" + line + "\n"

    return txt, original_op


def _tests_readme(_opts: ScaffoldOpts) -> str:
    """Generate README content for the tests/ directory.

    Creates a markdown file explaining the test directory structure and
    how to run different test categories.

    Args:
        _opts: PyScaffold options (unused but required by template signature).

    Returns:
        Markdown content for tests/README.md.
    """
    return """# Tests

This project separates fast unit tests from slower integration tests.

- `tests/unit/`: fast tests (imports, pure logic)
- `tests/integration/`: filesystem / external tool checks

Run:
- `pytest`
- `pytest -m "not integration"`
- `pytest -m integration`
"""


def _unit_test_import(opts: ScaffoldOpts) -> str:
    """Generate a basic unit test that verifies the package is importable.

    Creates a simple smoke test to verify the package can be imported
    without errors. This catches basic issues like syntax errors or
    missing dependencies early.

    Args:
        opts: PyScaffold options containing the package name.

    Returns:
        Python source code for tests/unit/test_import.py.
    """
    pkg = opts["package"]
    return f'''"""Unit smoke tests (fast)."""

import importlib


def test_package_importable():
    importlib.import_module("{pkg}")
'''


def _integration_test_layout(opts: ScaffoldOpts) -> str:
    """Generate an integration test that verifies project structure.

    Creates a test marked with ``@pytest.mark.integration`` that verifies
    the expected project layout exists (pyproject.toml, src directory, etc.).

    Args:
        opts: PyScaffold options containing the package name.

    Returns:
        Python source code for tests/integration/test_layout.py.
    """
    pkg = opts["package"]
    return f'''"""Integration-ish smoke tests (filesystem/layout)."""

from pathlib import Path
import pytest


@pytest.mark.integration
def test_project_layout_exists():
    root = Path(__file__).resolve().parents[2]
    assert (root / "pyproject.toml").exists()
    assert (root / "src" / "{pkg}").exists()
'''


def add_files(struct: Structure, opts: ScaffoldOpts) -> ActionParams:
    """Add Click CLI files and test structure to the project.

    This action adds the core Click-based CLI files and sets up the
    test directory structure with unit/integration separation.

    Files added:
        - ``src/<package>/cli.py`` - Click CLI entry point
        - ``src/<package>/api.py`` - Core API logic
        - ``src/<package>/__main__.py`` - ``python -m`` runner support
        - ``tests/README.md`` - Testing documentation
        - ``tests/unit/test_import.py`` - Import smoke test
        - ``tests/integration/test_layout.py`` - Structure verification test

    Also modifies ``.gitignore`` to exclude ``_version.py``.

    Args:
        struct: Current project structure dictionary.
        opts: PyScaffold scaffold options.

    Returns:
        Tuple of (modified structure, options).
    """

    cli_template = get_template("cli", relative_to=my_templates)
    api_template = get_template("api", relative_to=my_templates)
    runner_template = get_template("runner", relative_to=my_templates)

    project = opts.get("project") or "project"
    package = opts.get("package") or project.replace("-", "_")

    # Remove PyScaffold's default tests (skeleton-style)
    struct = reject(struct, Path("tests", "conftest.py"))
    struct = reject(struct, Path("tests", "test_skeleton.py"))

    # .gitignore: modify if present; otherwise create it.
    if ".gitignore" in struct:
        gitignore_leaf = modify_gitignore(struct[".gitignore"], opts)
    else:
        gitignore_leaf = (
            f"# Generated by setuptools_scm\nsrc/{package}/_version.py\n",
            NO_OVERWRITE,
        )

    files: Structure = {
        ".gitignore": gitignore_leaf,
        "src": {
            package: {
                "cli.py": (cli_template, NO_OVERWRITE),
                "api.py": (api_template, NO_OVERWRITE),
                "__main__.py": (runner_template, NO_OVERWRITE),
            }
        },
        "tests": {
            "README.md": (_tests_readme, NO_OVERWRITE),
            "unit": {
                "test_import.py": (_unit_test_import, NO_OVERWRITE),
            },
            "integration": {
                "test_layout.py": (_integration_test_layout, NO_OVERWRITE),
            },
        },
    }

    return merge(struct, files), opts


def add_clickstart_templates(struct: Structure, opts: ScaffoldOpts) -> ActionParams:
    """Add project-level configuration files from ClickStart templates.

    Renders and adds the main project configuration files, replacing
    PyScaffold defaults with ClickStart's modern tooling setup.

    Files added:
        - ``Makefile`` - Development task automation
        - ``pyproject.toml`` - Project metadata and tool configuration
        - ``.pre-commit-config.yaml`` - Pre-commit hooks (Ruff-based)

    Files removed:
        - ``setup.cfg`` - Legacy configuration (replaced by pyproject.toml)
        - ``.isort.cfg`` - Replaced by Ruff
        - Any existing ``.pre-commit-config.yaml`` (replaced with Ruff-only config)

    Args:
        struct: Current project structure dictionary.
        opts: PyScaffold scaffold options.

    Returns:
        Tuple of (modified structure, options).
    """

    def render_template(name: str) -> str:
        tpl = get_template(name, relative_to=my_templates)
        txt = reify_content(tpl, opts)
        return _substitute_brace_vars(txt, opts)

    # If PyScaffold's built-in --pre-commit already added a default config,
    # remove it so ClickStart can enforce Ruff-only.
    struct.pop(".pre-commit-config.yaml", None)
    struct.pop(".isort.cfg", None)

    files: Structure = {
        "Makefile": (render_template("Makefile"), NO_OVERWRITE),
        "pyproject.toml": (render_template("pyproject.toml"), NO_OVERWRITE),
        ".pre-commit-config.yaml": (
            render_template(".pre-commit-config.yaml"),
            NO_OVERWRITE,
        ),
    }

    struct.pop("setup.cfg", None)
    return merge(struct, files), opts


def add_markdown_docs(struct: Structure, opts: ScaffoldOpts) -> ActionParams:
    """Replace PyScaffold's RST documentation with Markdown equivalents.

    Removes all default RST documentation files and replaces them with
    Markdown versions using MyST-Parser for Sphinx integration. This provides
    modern, easier-to-write documentation.

    Files removed (RST):
        - ``README.rst``, ``AUTHORS.rst``, ``CHANGELOG.rst``, ``CONTRIBUTING.rst``
        - ``docs/*.rst`` (index, readme, authors, changelog, contributing, license)
        - ``docs/conf.py`` (replaced with MyST-aware version)

    Files added (Markdown):
        - ``README.md``, ``AUTHORS.md``, ``CHANGELOG.md``, ``CONTRIBUTING.md``
        - ``docs/*.md`` (index, readme, authors, changelog, contributing, license)
        - ``docs/conf.py`` - Sphinx config with MyST-Parser
        - ``docs/requirements.txt`` - Sphinx dependencies
        - ``.readthedocs.yml`` - ReadTheDocs configuration

    Args:
        struct: Current project structure dictionary.
        opts: PyScaffold scaffold options.

    Returns:
        Tuple of (modified structure, options).
    """

    def render_template(name: str) -> str:
        tpl = get_template(name, relative_to=my_templates)
        txt = reify_content(tpl, opts)
        return _substitute_brace_vars(txt, opts)

    # Reject PyScaffold's default RST documentation files
    struct = reject(struct, Path("README.rst"))
    struct = reject(struct, Path("AUTHORS.rst"))
    struct = reject(struct, Path("CHANGELOG.rst"))
    struct = reject(struct, Path("CONTRIBUTING.rst"))
    struct = reject(struct, Path("docs", "index.rst"))
    struct = reject(struct, Path("docs", "readme.rst"))
    struct = reject(struct, Path("docs", "authors.rst"))
    struct = reject(struct, Path("docs", "changelog.rst"))
    struct = reject(struct, Path("docs", "contributing.rst"))
    struct = reject(struct, Path("docs", "license.rst"))
    struct = reject(struct, Path("docs", "conf.py"))

    # Add Markdown documentation files
    files: Structure = {
        "README.md": (render_template("README.md"), NO_OVERWRITE),
        "AUTHORS.md": (render_template("AUTHORS.md"), NO_OVERWRITE),
        "CHANGELOG.md": (render_template("CHANGELOG.md"), NO_OVERWRITE),
        "CONTRIBUTING.md": (render_template("CONTRIBUTING.md"), NO_OVERWRITE),
        ".readthedocs.yml": (render_template(".readthedocs.yml"), NO_OVERWRITE),
        "docs": {
            "index.md": (render_template("docs/index.md"), NO_OVERWRITE),
            "readme.md": (render_template("docs/readme.md"), NO_OVERWRITE),
            "authors.md": (render_template("docs/authors.md"), NO_OVERWRITE),
            "changelog.md": (render_template("docs/changelog.md"), NO_OVERWRITE),
            "contributing.md": (render_template("docs/contributing.md"), NO_OVERWRITE),
            "license.md": (render_template("docs/license.md"), NO_OVERWRITE),
            "conf.py": (render_template("docs/conf.py"), NO_OVERWRITE),
            "requirements.txt": (render_template("docs/requirements.txt"), NO_OVERWRITE),
        },
    }

    return merge(struct, files), opts


def reject_file(struct: Structure, opts: ScaffoldOpts) -> ActionParams:
    """Remove unwanted default files from PyScaffold's structure.

    Rejects (removes) files that ClickStart doesn't want in the final
    project, including PyScaffold's default skeleton module and legacy
    packaging files.

    Files removed:
        - ``src/<package>/skeleton.py`` - PyScaffold's example module
        - ``setup.py`` - Legacy setup script
        - ``setup.cfg`` - Legacy configuration (replaced by pyproject.toml)

    Args:
        struct: Current project structure dictionary.
        opts: PyScaffold scaffold options.

    Returns:
        Tuple of (modified structure, options).
    """
    pkg = opts["package"]

    struct = reject(struct, Path("src", pkg, "skeleton.py"))
    struct = reject(struct, Path("setup.py"))
    struct = reject(struct, Path("setup.cfg"))

    return struct, opts


def _clickstart_version() -> str:
    """Get the installed version of pyscaffoldext-clickstart.

    Attempts to determine the version using importlib.metadata first,
    which works for both regular and editable installs. Falls back to
    reading from the generated _version.py file, and finally returns
    "unknown" if version cannot be determined.

    Returns:
        Version string (e.g., "1.2.3") or "unknown" if not determinable.
    """
    # Best: read the installed distribution version (works for editable installs)
    try:
        # Find which distribution provides the top-level package "pyscaffoldext"
        dist_names = packages_distributions().get("pyscaffoldext", [])
        if dist_names:
            return dist_version(dist_names[0])
    except Exception:
        pass

    # Fallback: try your generated _version.py (setuptools-scm style)
    try:
        from ._version import version as v  # type: ignore

        return v
    except Exception:
        return "unknown"


class Clickstart(Extension):
    """PyScaffold extension for generating Click-based CLI projects.

    This extension modifies PyScaffold's default project structure to create
    a modern, production-ready CLI application with sensible defaults.

    Features:
        - Click-based CLI with entry point configuration
        - Modern pyproject.toml-only configuration
        - Ruff for linting/formatting (replaces Black, isort, flake8)
        - pytest with unit/integration test separation
        - Sphinx documentation with MyST-Parser (Markdown)
        - Makefile for development task automation
        - Pre-commit hooks configured

    Usage:
        The extension is activated via the ``--clickstart`` flag::

            putup --clickstart my_project

    Attributes:
        name: Extension name used for the CLI flag.
        help_text: Description shown in ``putup --help``.

    Example:
        >>> from pyscaffoldext.clickstart.extension import Clickstart
        >>> ext = Clickstart()
        >>> print(ext.flag)
        --clickstart
    """

    name = "clickstart"
    help_text = "Generate a Click-based CLI project scaffold (ClickStart templates)."
    description = help_text

    def augment_cli(self, parser):
        """Add ClickStart-specific CLI arguments.

        Adds the ``--clickstart-version`` argument to display the installed
        version of the ClickStart extension.

        Args:
            parser: argparse.ArgumentParser instance to augment.
        """
        super().augment_cli(parser)
        parser.add_argument(
            "--clickstart-version",
            action="version",
            version=f"ClickStart {_clickstart_version()}",
        )

    def activate(self, actions: List[Action]) -> List[Action]:
        """Register ClickStart actions with PyScaffold.

        Registers the following actions in order:

        1. ``add_files`` - After "define_structure"
           Adds CLI, API, and test files
        2. ``add_clickstart_templates`` - Before "create_structure"
           Adds Makefile, pyproject.toml, pre-commit config
        3. ``add_markdown_docs`` - Before "create_structure"
           Replaces RST docs with Markdown
        4. ``reject_file`` - Before "create_structure"
           Removes unwanted default files

        Args:
            actions: List of PyScaffold actions to modify.

        Returns:
            Modified list of actions with ClickStart handlers registered.
        """
        actions = self.register(actions, add_files, after="define_structure")
        actions = self.register(actions, add_clickstart_templates, before="create_structure")
        actions = self.register(actions, add_markdown_docs, before="create_structure")
        actions = self.register(actions, reject_file, before="create_structure")
        return actions


# --------------------------------------------------------------------------- #
# setup.cfg modification (legacy mode only)
# --------------------------------------------------------------------------- #


def modify_setupcfg(definition: Leaf, opts: ScaffoldOpts) -> ResolvedLeaf:
    """Modify setup.cfg to inject dependencies and entry points."""
    contents, original_op = resolve_leaf(definition)
    if contents is None:
        raise ValueError("File contents for setup.cfg should not be None")

    setupcfg = ConfigUpdater()
    setupcfg.read_string(reify_content(contents, opts))

    modifiers = (add_install_requires, py_requires, add_entry_point)
    new_setupcfg = reduce(lambda acc, fn: fn(acc, opts), modifiers, setupcfg)
    return str(new_setupcfg), original_op


def add_install_requires(setupcfg: ConfigUpdater, _opts) -> ConfigUpdater:
    requires = setupcfg["options"]
    requires["install_requires"].set_values(REQUIREMENT_DEPENDENCIES)
    return setupcfg


def py_requires(setupcfg: ConfigUpdater, _opts) -> ConfigUpdater:
    (
        setupcfg["options"]["install_requires"]
        .add_before.comment("# Minimum Python Version 3.12 required")
        .option("python_requires", ">=3.12,<3.13")
    )
    return setupcfg


def add_entry_point(setupcfg: ConfigUpdater, opts: ScaffoldOpts) -> ConfigUpdater:
    entry_points_key = "options.entry_points"

    if not setupcfg.has_section(entry_points_key):
        setupcfg["options"].add_after.section(entry_points_key)

    entry_points = setupcfg[entry_points_key]
    entry_points.insert_at(0).option("console_scripts")
    template = "{package} = {package}.cli:cli"
    value = template.format(**opts)
    entry_points["console_scripts"].set_values([value])
    return setupcfg
