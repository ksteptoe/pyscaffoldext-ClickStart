from __future__ import annotations

from functools import reduce
from importlib.metadata import PackageNotFoundError, packages_distributions
from importlib.metadata import version as dist_version
from pathlib import Path
from typing import List

from pyscaffold.actions import Action, ActionParams, ScaffoldOpts, Structure
from pyscaffold.extensions import Extension
from pyscaffold.operations import no_overwrite
from pyscaffold.structure import (
    Leaf,
    ResolvedLeaf,
    merge,
    reify_content,
    reject,
    resolve_leaf,
)
from pyscaffold.templates import get_template
from pyscaffold.update import ConfigUpdater

from . import templates as my_templates

NO_OVERWRITE = no_overwrite()

# For backward compatibility only â€” safe to remove once setup.cfg is deprecated
REQUIREMENT_DEPENDENCIES = (
    "click>=8.1",
    "pytest>=8",
    "pytest-cov>=5",
)


def _substitute_brace_vars(text: str, opts: ScaffoldOpts) -> str:
    """Support legacy {{ project_name }} / {{ package_name }} placeholders.

    We keep this because your templates currently use brace vars (not $vars).
    """
    project = (
        opts.get("project")
        or opts.get("project_name")
        or opts.get("name")
        or "project"
    )
    package = (
        opts.get("package")
        or opts.get("package_name")
        or project.replace("-", "_")
    )
    return (
        text.replace("{{ project_name }}", project)
        .replace("{{project_name}}", project)
        .replace("{{ package_name }}", package)
        .replace("{{package_name}}", package)
        .replace("{{package}}", package)
    )


def modify_gitignore(definition: Leaf, opts: ScaffoldOpts) -> ResolvedLeaf:
    """Ensure setuptools_scm output is ignored: src/<package>/_version.py."""
    contents, original_op = resolve_leaf(definition)
    txt = reify_content(contents, opts) if contents is not None else ""

    project = opts.get("project") or "project"
    package = opts.get("package") or project.replace("-", "_")
    line = f"src/{package}/_version.py"

    if line not in txt.splitlines():
        if txt and not txt.endswith("\n"):
            txt += "\n"
        txt += "# Generated by setuptools_scm\n" + line + "\n"

    return txt, original_op

def _tests_readme(_opts: ScaffoldOpts) -> str:
    return """# Tests

This project separates fast unit tests from slower integration tests.

- `tests/unit/`: fast tests (imports, pure logic)
- `tests/integration/`: filesystem / external tool checks

Run:
- `pytest`
- `pytest -m "not integration"`
- `pytest -m integration`
"""


def _unit_test_import(opts: ScaffoldOpts) -> str:
    pkg = opts["package"]
    return f'''"""Unit smoke tests (fast)."""

import importlib


def test_package_importable():
    importlib.import_module("{pkg}")
'''


def _integration_test_layout(opts: ScaffoldOpts) -> str:
    pkg = opts["package"]
    return f'''"""Integration-ish smoke tests (filesystem/layout)."""

from pathlib import Path
import pytest


@pytest.mark.integration
def test_project_layout_exists():
    root = Path(__file__).resolve().parents[2]
    assert (root / "pyproject.toml").exists()
    assert (root / "src" / "{pkg}").exists()
'''

def add_files(struct: Structure, opts: ScaffoldOpts) -> ActionParams:
    """Add CLI, API, runner, tests, and .gitignore augmentation."""

    cli_template = get_template("cli", relative_to=my_templates)
    api_template = get_template("api", relative_to=my_templates)
    runner_template = get_template("runner", relative_to=my_templates)

    project = opts.get("project") or "project"
    package = opts.get("package") or project.replace("-", "_")

    # Remove PyScaffold's default tests (skeleton-style)
    struct = reject(struct, Path("tests", "conftest.py"))
    struct = reject(struct, Path("tests", "test_skeleton.py"))

    # .gitignore: modify if present; otherwise create it.
    if ".gitignore" in struct:
        gitignore_leaf = modify_gitignore(struct[".gitignore"], opts)
    else:
        gitignore_leaf = (
            f"# Generated by setuptools_scm\nsrc/{package}/_version.py\n",
            NO_OVERWRITE,
        )

    files: Structure = {
        ".gitignore": gitignore_leaf,
        "src": {
            package: {
                "cli.py": (cli_template, NO_OVERWRITE),
                "api.py": (api_template, NO_OVERWRITE),
                "__main__.py": (runner_template, NO_OVERWRITE),
            }
        },
        "tests": {
            "README.md": (_tests_readme, NO_OVERWRITE),
            "unit": {
                "test_import.py": (_unit_test_import, NO_OVERWRITE),
            },
            "integration": {
                "test_layout.py": (_integration_test_layout, NO_OVERWRITE),
            },
        },
    }

    return merge(struct, files), opts



def add_clickstart_templates(struct: Structure, opts: ScaffoldOpts) -> ActionParams:
    """Add rendered project-level templates: Makefile, pyproject.toml, pre-commit."""

    def render_template(name: str) -> str:
        tpl = get_template(name, relative_to=my_templates)
        txt = reify_content(tpl, opts)
        return _substitute_brace_vars(txt, opts)

    # If PyScaffold's built-in --pre-commit already added a default config,
    # remove it so ClickStart can enforce Ruff-only.
    struct.pop(".pre-commit-config.yaml", None)
    struct.pop(".isort.cfg", None)

    files: Structure = {
        "Makefile": (render_template("Makefile"), NO_OVERWRITE),
        "pyproject.toml": (render_template("pyproject.toml"), NO_OVERWRITE),
        ".pre-commit-config.yaml": (
            render_template(".pre-commit-config.yaml"),
            NO_OVERWRITE,
        ),
    }

    struct.pop("setup.cfg", None)
    return merge(struct, files), opts

def reject_file(struct: Structure, opts: ScaffoldOpts) -> ActionParams:
    """Reject default skeleton/legacy packaging files from PyScaffold."""
    pkg = opts["package"]

    struct = reject(struct, Path("src", pkg, "skeleton.py"))
    struct = reject(struct, Path("setup.py"))
    struct = reject(struct, Path("setup.cfg"))

    return struct, opts

def _clickstart_version() -> str:
    # Best: read the installed distribution version (works for editable installs)
    try:
        # Find which distribution provides the top-level package "pyscaffoldext"
        dist_names = packages_distributions().get("pyscaffoldext", [])
        if dist_names:
            return dist_version(dist_names[0])
    except Exception:
        pass

    # Fallback: try your generated _version.py (setuptools-scm style)
    try:
        from ._version import version as v  # type: ignore
        return v
    except Exception:
        return "unknown"

class Clickstart(Extension):
    """Main entry point for the Clickstart PyScaffold extension."""

    # Name is optional (entry-point name usually defines the flag),
    # but harmless and can make things clearer.
    name = "clickstart"

    # This is the critical one for the error you're seeing:
    help_text = "Generate a Click-based CLI project scaffold (ClickStart templates)."

    # Some PyScaffold versions also look at description:
    description = help_text

    def augment_cli(self, parser):
        super().augment_cli(parser)
        parser.add_argument(
            "--clickstart-version",
            action="version",
            version=f"ClickStart {_clickstart_version()}",
        )

    def activate(self, actions: List[Action]) -> List[Action]:
        actions = self.register(actions, add_files, after="define_structure")

        # Run late, so we override anything other extensions added (incl. pre_commit)
        actions = self.register(actions, add_clickstart_templates, before="create_structure")

        # Either fold reject_file into add_clickstart_templates (simplest),
        # or also register it late:
        actions = self.register(actions, reject_file, before="create_structure")

        return actions


# --------------------------------------------------------------------------- #
# setup.cfg modification (legacy mode only)
# --------------------------------------------------------------------------- #


def modify_setupcfg(definition: Leaf, opts: ScaffoldOpts) -> ResolvedLeaf:
    """Modify setup.cfg to inject dependencies and entry points."""
    contents, original_op = resolve_leaf(definition)
    if contents is None:
        raise ValueError("File contents for setup.cfg should not be None")

    setupcfg = ConfigUpdater()
    setupcfg.read_string(reify_content(contents, opts))

    modifiers = (add_install_requires, py_requires, add_entry_point)
    new_setupcfg = reduce(lambda acc, fn: fn(acc, opts), modifiers, setupcfg)
    return str(new_setupcfg), original_op


def add_install_requires(setupcfg: ConfigUpdater, _opts) -> ConfigUpdater:
    requires = setupcfg["options"]
    requires["install_requires"].set_values(REQUIREMENT_DEPENDENCIES)
    return setupcfg


def py_requires(setupcfg: ConfigUpdater, _opts) -> ConfigUpdater:
    (
        setupcfg["options"]["install_requires"]
        .add_before.comment("# Minimum Python Version 3.12 required")
        .option("python_requires", ">=3.12,<3.13")
    )
    return setupcfg


def add_entry_point(setupcfg: ConfigUpdater, opts: ScaffoldOpts) -> ConfigUpdater:
    entry_points_key = "options.entry_points"

    if not setupcfg.has_section(entry_points_key):
        setupcfg["options"].add_after.section(entry_points_key)

    entry_points = setupcfg[entry_points_key]
    entry_points.insert_at(0).option("console_scripts")
    template = "{package} = {package}.cli:cli"
    value = template.format(**opts)
    entry_points["console_scripts"].set_values([value])
    return setupcfg


